name: Tag push
description: Move a tag to HEAD and push it to the remote after a successful deploy
author: Terje Sandstrom
branding:
  icon: tag
  color: green

inputs:
  tag:
    description: Tag name to move and push (e.g., last-deploy)
    required: true
    default: last-deploy
  remote:
    description: Git remote name
    default: origin
  expected_base_tag:
    description: Expected base tag from rollup check (optional safety check)
    required: false
    default: ""

runs:
  using: composite
  steps:
    - shell: bash
      run: |
        set -euo pipefail
        tag="${{ inputs.tag }}"
        remote="${{ inputs.remote }}"
        expected="${{ inputs.expected_base_tag }}"
        
        # Get current context for debugging
        current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD")
        current_sha=$(git rev-parse HEAD)
        current_short=$(git rev-parse --short HEAD)
        
        echo "ðŸ·ï¸ Moving '$tag' to HEAD and pushing to '$remote'â€¦"
        echo "Current branch: $current_branch"
        echo "Current HEAD: $current_sha ($current_short)"
        
        # Safety check: verify tag matches expected from rollup
        if [ -n "$expected" ]; then
          echo ""
          echo "ðŸ”’ Safety check: Expected base tag from rollup = '$expected'"
          if [ "$expected" != "$tag" ]; then
            echo ""
            echo "âŒ ERROR: Tag mismatch detected!"
            echo "   Rollup checked tag: '$expected'"
            echo "   Trying to push tag: '$tag'"
            echo ""
            echo "This usually means:"
            echo "  - You passed different tag names to rollup vs push"
            echo "  - There's a typo in one of the tag names"
            echo ""
            echo "Please ensure both actions use the same tag parameter."
            exit 1
          fi
          echo "âœ“ Tag names match"
        else
          echo ""
          echo "â„¹ï¸  Safety check skipped (no expected_base_tag provided)"
          echo "   This is normal for manual invocations"
        fi
        
        # Fetch only the specific tag we care about (efficient)
        echo ""
        echo "Fetching tag '$tag' from $remote..."
        git fetch "$remote" "+refs/tags/$tag:refs/tags/$tag" --force --no-recurse-submodules 2>/dev/null || echo "Tag doesn't exist yet on remote"
        
        # Show old tag location if it exists
        if git rev-parse -q --verify "refs/tags/$tag" >/dev/null 2>&1; then
          old_sha=$(git rev-parse "refs/tags/$tag")
          old_short=$(git rev-parse --short "refs/tags/$tag")
          echo "Old tag location: $old_sha ($old_short)"
        else
          echo "Tag does not exist yet (will create new)"
        fi
        
        # Force move/create tag to current HEAD
        echo ""
        echo "Creating/moving tag locally..."
        git tag -f "$tag"
        new_local_sha=$(git rev-parse "refs/tags/$tag")
        echo "âœ“ Tag moved locally to $new_local_sha"
        
        # Verify local tag before pushing
        if [ "$new_local_sha" != "$current_sha" ]; then
          echo "âœ— ERROR: Local tag is at $new_local_sha but HEAD is at $current_sha"
          exit 1
        fi
        
        # Force push to remote with explicit refspec
        echo ""
        echo "Force pushing tag to $remote..."
        git push -f "$remote" "refs/tags/$tag:refs/tags/$tag"
        echo "âœ“ Tag pushed to $remote"
        
        # Verify on remote using ls-remote (doesn't use cache)
        echo ""
        echo "Verifying tag on remote..."
        remote_sha=$(git ls-remote "$remote" "refs/tags/$tag" | awk '{print $1}')
        
        if [ -z "$remote_sha" ]; then
          echo "âš  WARNING: Could not verify tag on remote"
        elif [ "$remote_sha" = "$current_sha" ]; then
          echo "âœ“ Verified: Remote tag matches HEAD ($remote_sha)"
        else
          echo "âš  WARNING: Remote tag ($remote_sha) doesn't match HEAD ($current_sha)"
        fi
        
        {
          echo "### Tag push"
          echo "- **Tag moved**: \`$tag\`"
          echo "- **Remote**: \`$remote\`"
          echo "- **Branch**: \`$current_branch\`"
          echo "- **New location**: \`$current_short\` (\`$current_sha\`)"
          if [ -n "${old_short:-}" ]; then
            echo "- **Previous location**: \`$old_short\` (\`$old_sha\`)"
          fi
        } >> "$GITHUB_STEP_SUMMARY"
        
        echo ""
        echo "âœ“ Complete: $tag â†’ $current_short"
